name: 构建并部署 Spring Boot 应用

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: [self-hosted, Linux, ARM64]

    steps:
      # 1️⃣ 拉取最新代码（改用 SSH，需预先在 secrets 配置 REPO_SSH_KEY）
      - name: 拉取代码（SSH）
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.REPO_SSH_KEY }}
          fetch-depth: 1
          persist-credentials: false

      # 2️⃣ 设置 JDK 17
      - name: 设置 JDK 17 环境
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      # 3️⃣ 赋予 mvnw 可执行权限
      - name: 赋予 mvnw 可执行权限
        run: chmod +x mvnw

      # 4️⃣ 构建 Spring Boot 项目
      - name: 构建项目
        run: ./mvnw clean package -DskipTests -B -q

      # 5️⃣ 使用 Docker 以 runner 用户运行应用，避免 systemd/sudo
      - name: 以 Docker 方式部署
        shell: bash
        run: |
          set -euo pipefail

          # 找到最新 JAR（跳过 *.jar.original）
          JAR_FILE=$(find target -maxdepth 1 -type f -name "*.jar" ! -name "*.jar.original" -printf "%T@ %p\n" | sort -nr | awk 'NR==1{print $2}')
          if [ -z "${JAR_FILE:-}" ]; then
            echo "未找到可部署的 JAR 文件"
            exit 1
          fi

          # 解析为绝对路径，避免 docker 卷名误判
          JAR_FILE=$(readlink -f "$JAR_FILE")

          APP_NAME="hello-app"
          HOST_PORT=8080

          # 确保旧容器被清理
          docker rm -f "$APP_NAME" 2>/dev/null || true

          # 以挂载方式运行，避免在镜像中重复打包 JAR
          docker run -d \
            --name "$APP_NAME" \
            --restart=always \
            -p "${HOST_PORT}:8080" \
            -v "${JAR_FILE}:/app/app.jar:ro" \
            eclipse-temurin:17-jre \
            java -jar /app/app.jar

          docker ps --filter "name=${APP_NAME}"
